{"version":3,"file":"init.min.js","sources":["../../src/inject_ai/init.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Fetches AI data and injects it into grading forms.\n *\n * @module      local_assign_ai/inject_ai/init\n * @copyright   2025 Datacurso\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Notification from 'core/notification';\nimport { get_string as getString } from 'core/str';\nimport Log from 'core/log';\nimport { injectMessage } from './inject_message';\nimport { injectRubric } from './inject_rubric';\nimport { injectGuide } from './inject_guide';\nimport { injectSimpleGrade } from './inject_simple_grade';\n\n/**\n * Injects AI-generated feedback, rubric selections and/or grade\n * into the assignment grading form for the current student.\n *\n * @param {Object} params                      Required parameters.\n * @param {string} params.token                Approval token used to fetch AI details.\n * @param {number} params.userid               ID of the student being graded.\n * @param {number} params.assignmentid         Assignment identifier (cmid) from the grader URL.\n * @param {number} params.courseid             Course ID of the assignment.\n */\nexport const init = async ({ token, userid, assignmentid, courseid }) => {\n    if (!token || !userid || !assignmentid || !courseid) {\n        return;\n    }\n\n    const [\n        strErrorParsing,\n        strRubricArray,\n        strRubricSuccess,\n        strRubricFailed\n    ] = await Promise.all([\n        getString('errorparsingrubric', 'local_assign_ai'),\n        getString('rubricmustarray', 'local_assign_ai'),\n        getString('rubricsuccess', 'local_assign_ai'),\n        getString('rubricfailed', 'local_assign_ai'),\n    ]);\n\n    Ajax.call([{\n        methodname: 'local_assign_ai_get_details',\n        args: { courseid, cmid: assignmentid, userid }\n    }])[0]\n        .done(data => {\n            const message = data.message ?? data.reply ?? '';\n            const rubricResponse = data.rubric_response ?? data.rubric ?? null;\n            const guideResponse = data.assessment_guide_response ?? null;\n            const grade = data.grade ?? null;\n\n            Log.debug('[local_assign_ai] Data received:', { reference: message, rubricResponse, guideResponse, grade });\n\n            let successfulInjection = false;\n\n            const runInjection = () => {\n                let anyInjected = false;\n\n                // 1. Message\n                if (injectMessage(message)) {\n                    // Message injected\n                }\n\n                // 2. Parse Data\n                let advancedData = null;\n                let isGuide = false;\n\n                if (guideResponse && guideResponse !== 'null' && guideResponse !== '') {\n                    try {\n                        advancedData = typeof guideResponse === 'string' ? JSON.parse(guideResponse) : guideResponse;\n                        isGuide = true;\n                    } catch (e) {\n                        Log.error('[local_assign_ai] Error parsing guide:', e);\n                        Notification.addNotification({ message: `${strErrorParsing} ${e.message}`, type: 'error' });\n                        return false;\n                    }\n                } else if (rubricResponse && rubricResponse !== 'null' && rubricResponse !== '') {\n                    try {\n                        advancedData = typeof rubricResponse === 'string' ? JSON.parse(rubricResponse) : rubricResponse;\n                        // Legacy fallback check for object-in-rubric-field\n                        if (!Array.isArray(advancedData) && typeof advancedData === 'object') {\n                            isGuide = true;\n                        }\n                    } catch (e) {\n                        Log.error('[local_assign_ai] Error parsing rubric:', e);\n                        Notification.addNotification({ message: `${strErrorParsing} ${e.message}`, type: 'error' });\n                        return false;\n                    }\n                }\n\n                // 3. Dispatch\n                if (advancedData) {\n                    if (isGuide) {\n                        if (injectGuide(advancedData)) {\n                            anyInjected = true;\n                        }\n                    } else if (Array.isArray(advancedData)) {\n                        if (injectRubric(advancedData, strRubricArray)) {\n                            anyInjected = true;\n                        }\n                    }\n                } else {\n                    if (injectSimpleGrade(grade)) {\n                        anyInjected = true;\n                    }\n                }\n\n                return anyInjected;\n            };\n\n            const showResults = (success) => {\n                Notification.addNotification({\n                    message: success ? strRubricSuccess : strRubricFailed,\n                    type: success ? 'success' : 'warning'\n                });\n            };\n\n            // Polling\n            let attempts = 0;\n            const maxAttempts = 100;\n            const interval = setInterval(() => {\n                attempts++;\n                if (!successfulInjection) {\n                    if (runInjection()) {\n                        successfulInjection = true;\n                    }\n                }\n                if ((successfulInjection && attempts > 20) || attempts > maxAttempts) {\n                    clearInterval(interval);\n                    if (successfulInjection) {\n                        showResults(true);\n                    }\n                }\n            }, 300);\n\n            // Observer\n            const container = document.querySelector('[data-region=\"grading-actions-form\"]') ||\n                document.querySelector('.gradingform_rubric') ||\n                document.querySelector('.gradingform_guide') ||\n                document.body;\n\n            if (container) {\n                const observer = new MutationObserver(() => {\n                    const criteria = document.querySelectorAll('tr.criterion, .gradingform_guide tr');\n                    if (criteria.length > 0 && !successfulInjection) {\n                        if (runInjection()) {\n                            successfulInjection = true;\n                            observer.disconnect();\n                        }\n                    }\n                });\n                observer.observe(container, { childList: true, subtree: true });\n                setTimeout(() => observer.disconnect(), 20000);\n            }\n        })\n        .fail(Notification.exception);\n};\n"],"names":["async","token","userid","assignmentid","courseid","strErrorParsing","strRubricArray","strRubricSuccess","strRubricFailed","Promise","all","call","methodname","args","cmid","done","data","message","reply","rubricResponse","rubric_response","rubric","guideResponse","assessment_guide_response","grade","debug","reference","successfulInjection","runInjection","anyInjected","advancedData","isGuide","JSON","parse","e","error","addNotification","type","Array","isArray","attempts","interval","setInterval","success","clearInterval","container","document","querySelector","body","observer","MutationObserver","querySelectorAll","length","disconnect","observe","childList","subtree","setTimeout","fail","Notification","exception"],"mappings":";;;;;;;0NA0CoBA,MAAAA,WAAOC,MAAEA,MAAFC,OAASA,OAATC,aAAiBA,aAAjBC,SAA+BA,oBACjDH,OAAUC,QAAWC,cAAiBC,uBAKvCC,gBACAC,eACAC,iBACAC,uBACMC,QAAQC,IAAI,EAClB,mBAAU,qBAAsB,oBAChC,mBAAU,kBAAmB,oBAC7B,mBAAU,gBAAiB,oBAC3B,mBAAU,eAAgB,mCAGzBC,KAAK,CAAC,CACPC,WAAY,8BACZC,KAAM,CAAET,SAAAA,SAAUU,KAAMX,aAAcD,OAAAA,WACtC,GACCa,MAAKC,mGACIC,4CAAUD,KAAKC,+CAAWD,KAAKE,6BAAS,GACxCC,2DAAiBH,KAAKI,uEAAmBJ,KAAKK,8BAAU,KACxDC,4CAAgBN,KAAKO,iFAA6B,KAClDC,0BAAQR,KAAKQ,yCAAS,kBAExBC,MAAM,mCAAoC,CAAEC,UAAWT,QAASE,eAAAA,eAAgBG,cAAAA,cAAeE,MAAAA,YAE/FG,qBAAsB,QAEpBC,aAAe,SACbC,aAAc,GAGd,iCAAcZ,aAKda,aAAe,KACfC,SAAU,KAEVT,eAAmC,SAAlBA,eAA8C,KAAlBA,kBAEzCQ,aAAwC,iBAAlBR,cAA6BU,KAAKC,MAAMX,eAAiBA,cAC/ES,SAAU,EACZ,MAAOG,uBACDC,MAAM,yCAA0CD,yBACvCE,gBAAgB,CAAEnB,kBAAYZ,4BAAmB6B,EAAEjB,SAAWoB,KAAM,WAC1E,OAER,GAAIlB,gBAAqC,SAAnBA,gBAAgD,KAAnBA,mBAElDW,aAAyC,iBAAnBX,eAA8Ba,KAAKC,MAAMd,gBAAkBA,eAE5EmB,MAAMC,QAAQT,eAAyC,iBAAjBA,eACvCC,SAAU,GAEhB,MAAOG,uBACDC,MAAM,0CAA2CD,yBACxCE,gBAAgB,CAAEnB,kBAAYZ,4BAAmB6B,EAAEjB,SAAWoB,KAAM,WAC1E,SAKXP,aACIC,SACI,6BAAYD,gBACZD,aAAc,GAEXS,MAAMC,QAAQT,gBACjB,+BAAaA,aAAcxB,kBAC3BuB,aAAc,IAIlB,0CAAkBL,SAClBK,aAAc,GAIfA,iBAWPW,SAAW,QAETC,SAAWC,aAAY,KAVRC,IAAAA,QAWjBH,WACKb,qBACGC,iBACAD,qBAAsB,IAGzBA,qBAAuBa,SAAW,IAAOA,SAR9B,OASZI,cAAcH,UACVd,sBAnBSgB,SAoBG,wBAnBPP,gBAAgB,CACzBnB,QAAS0B,QAAUpC,iBAAmBC,gBACtC6B,KAAMM,QAAU,UAAY,gBAoBjC,KAGGE,UAAYC,SAASC,cAAc,yCACrCD,SAASC,cAAc,wBACvBD,SAASC,cAAc,uBACvBD,SAASE,QAETH,UAAW,OACLI,SAAW,IAAIC,kBAAiB,KACjBJ,SAASK,iBAAiB,uCAC9BC,OAAS,IAAMzB,qBACpBC,iBACAD,qBAAsB,EACtBsB,SAASI,iBAIrBJ,SAASK,QAAQT,UAAW,CAAEU,WAAW,EAAMC,SAAS,IACxDC,YAAW,IAAMR,SAASI,cAAc,SAG/CK,KAAKC,sBAAaC"}