{"version":3,"file":"init.min.js","sources":["../../src/inject_ai/init.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Fetches AI data and injects it into grading forms.\n *\n * @module      local_assign_ai/inject_ai/init\n * @copyright   2025 Datacurso\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Notification from 'core/notification';\nimport { get_string as getString } from 'core/str';\nimport { injectMessage } from './inject_message';\nimport { injectRubric } from './inject_rubric';\nimport { injectGuide } from './inject_guide';\nimport { injectSimpleGrade } from './inject_simple_grade';\nimport { normalizeString } from './normalize_string';\n\nlet activerunid = 0;\nlet activecleanup = null;\n\nconst parseInjectionData = (data) => {\n    const message = data.message ?? data.reply ?? '';\n    const rubricResponse = data.rubric_response ?? data.rubric ?? null;\n    const guideResponse = data.assessment_guide_response ?? null;\n    const grade = data.grade ?? null;\n    const status = data.status ?? 'none';\n\n    if (guideResponse && guideResponse !== 'null' && guideResponse !== '') {\n        return {\n            status,\n            message,\n            mode: 'guide',\n            payload: typeof guideResponse === 'string' ? JSON.parse(guideResponse) : guideResponse,\n            grade,\n        };\n    }\n\n    if (rubricResponse && rubricResponse !== 'null' && rubricResponse !== '') {\n        const parsed = typeof rubricResponse === 'string' ? JSON.parse(rubricResponse) : rubricResponse;\n        const isGuideLike = !Array.isArray(parsed) && typeof parsed === 'object';\n        return {\n            status,\n            message,\n            mode: isGuideLike ? 'guide' : 'rubric',\n            payload: parsed,\n            grade,\n        };\n    }\n\n    if (grade !== null && grade !== undefined) {\n        return {\n            status,\n            message,\n            mode: 'simple',\n            payload: null,\n            grade,\n        };\n    }\n\n    return {\n        status,\n        message,\n        mode: 'none',\n        payload: null,\n        grade,\n    };\n};\n\n/**\n * Verifies that rubric levels selected in DOM match AI expected points.\n *\n * @param {Array} rubricData AI rubric payload.\n * @param {Element|Document} root Grading root element.\n * @returns {{ok: boolean, mismatches: Array}}\n */\nconst verifyRubricApplied = (rubricData, root) => {\n    if (!Array.isArray(rubricData)) {\n        return { ok: false, mismatches: [{ reason: 'rubric_data_not_array' }] };\n    }\n\n    const rows = Array.from(root.querySelectorAll('tr.criterion'));\n    const mismatches = [];\n\n    rubricData.forEach((criterionData) => {\n        const name = criterionData?.criterion || '';\n        const expected = parseFloat(criterionData?.levels?.[0]?.points ?? '');\n\n        const row = rows.find((rowItem) => {\n            const cell = rowItem.querySelector('td.description');\n            if (!cell) {\n                return false;\n            }\n            return normalizeString(cell.textContent.trim()) === normalizeString(name.trim());\n        });\n\n        if (!row) {\n            mismatches.push({ criterion: name, reason: 'row_not_found', expected });\n            return;\n        }\n\n        let selected = null;\n        const levels = Array.from(row.querySelectorAll('td.level'));\n        levels.forEach((levelCell) => {\n            const radio = levelCell.querySelector('input[type=\"radio\"]');\n            const isSelected = !!radio?.checked || levelCell.classList.contains('checked') ||\n                levelCell.getAttribute('aria-checked') === 'true';\n            if (!isSelected) {\n                return;\n            }\n            const score = levelCell.querySelector('.scorevalue');\n            if (!score) {\n                return;\n            }\n            selected = parseFloat(score.textContent.trim());\n        });\n\n        if (selected === null) {\n            mismatches.push({ criterion: name, reason: 'no_level_selected', expected });\n            return;\n        }\n\n        if (Math.abs(selected - expected) >= 0.1) {\n            mismatches.push({ criterion: name, reason: 'points_mismatch', expected, selected });\n        }\n    });\n\n    return { ok: mismatches.length === 0, mismatches };\n};\n\nconst resolveGradingRoot = () => {\n    const selectors = [\n        '#fitem_id_advancedgrading .gradingform_rubric',\n        '#fitem_id_advancedgrading .gradingform_guide',\n        '.gradingform_rubric.evaluate.editable',\n        '.gradingform_guide.evaluate.editable',\n        '.gradingform_rubric',\n        '.gradingform_guide',\n    ];\n\n    for (const selector of selectors) {\n        const nodes = Array.from(document.querySelectorAll(selector));\n        const visible = nodes.find((node) => node.offsetParent !== null || node.getClientRects().length > 0);\n        if (visible) {\n            return { root: visible, selector, visible: true, candidates: nodes.length };\n        }\n        if (nodes.length) {\n            return { root: nodes[0], selector, visible: false, candidates: nodes.length };\n        }\n    }\n\n    return { root: document, selector: 'document', visible: false, candidates: 0 };\n};\n\n/**\n * Injects AI-generated feedback, rubric selections and/or grade.\n *\n * @param {Object} params Required parameters.\n * @param {number} params.userid Current graded user id.\n * @param {number} params.assignmentid Assignment cmid.\n * @param {number} params.courseid Course id.\n * @returns {Promise<void>}\n */\nexport const init = async ({ userid, assignmentid, courseid }) => {\n    if (!userid || !assignmentid || !courseid) {\n        return;\n    }\n\n    if (activecleanup) {\n        activecleanup();\n    }\n\n    const runid = ++activerunid;\n    let intervalid = 0;\n    let observer = null;\n    let finished = false;\n    let successNotified = false;\n    let stableSuccessCount = 0;\n    let attempts = 0;\n\n    const isCurrentRun = () => runid === activerunid;\n    const cleanup = () => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        if (intervalid) {\n            clearInterval(intervalid);\n            intervalid = 0;\n        }\n        if (observer) {\n            observer.disconnect();\n            observer = null;\n        }\n    };\n\n    activecleanup = cleanup;\n\n    const [strRubricArray, strRubricSuccess] = await Promise.all([\n        getString('rubricmustarray', 'local_assign_ai'),\n        getString('rubricsuccess', 'local_assign_ai'),\n    ]);\n\n    if (!isCurrentRun()) {\n        return;\n    }\n\n    const fetchDetails = async () => Ajax.call([{\n        methodname: 'local_assign_ai_get_details',\n        args: { courseid, cmid: assignmentid, userid }\n    }])[0];\n\n    let cachedData = null;\n    let fetchcounter = 0;\n\n    const tryInjection = () => {\n        if (!isCurrentRun() || finished || !cachedData) {\n            return;\n        }\n\n        let parsed;\n        try {\n            parsed = parseInjectionData(cachedData);\n        } catch (e) {\n            cleanup();\n            return;\n        }\n\n        if (parsed.status === 'approve') {\n            cleanup();\n            return;\n        }\n\n        const rootInfo = resolveGradingRoot();\n        const gradingRoot = rootInfo.root;\n        const hasRubricRows = gradingRoot.querySelectorAll('tr.criterion').length > 0;\n\n        if (parsed.mode === 'rubric' && !rootInfo.visible) {\n            return;\n        }\n\n        if (parsed.mode === 'rubric' && !hasRubricRows) {\n            return;\n        }\n\n        injectMessage(parsed.message);\n\n        let applied = false;\n        if (parsed.mode === 'guide') {\n            applied = injectGuide(parsed.payload, { root: gradingRoot });\n        } else if (parsed.mode === 'rubric') {\n            const result = injectRubric(parsed.payload, strRubricArray, {\n                detailed: true,\n                root: gradingRoot,\n            });\n\n            applied = !!result.injected;\n\n            const verification = verifyRubricApplied(parsed.payload, gradingRoot);\n            if (!verification.ok) {\n                applied = false;\n            }\n        } else if (parsed.mode === 'simple') {\n            applied = injectSimpleGrade(parsed.grade);\n        }\n\n        if (!applied) {\n            stableSuccessCount = 0;\n            return;\n        }\n\n        stableSuccessCount++;\n\n        if (!successNotified && stableSuccessCount >= 2) {\n            Notification.addNotification({\n                message: strRubricSuccess,\n                type: 'success'\n            });\n            successNotified = true;\n            setTimeout(() => {\n                if (isCurrentRun()) {\n                    cleanup();\n                }\n            }, 500);\n        }\n    };\n\n    const refreshAndInject = async () => {\n        if (!isCurrentRun() || finished) {\n            return;\n        }\n\n        fetchcounter++;\n        if (!cachedData || fetchcounter % 4 === 0) {\n            try {\n                cachedData = await fetchDetails();\n                if (!isCurrentRun() || finished) {\n                    return;\n                }\n            } catch (e) {\n                Notification.exception(e);\n                cleanup();\n                return;\n            }\n        }\n\n        tryInjection();\n    };\n\n    await refreshAndInject();\n    if (!isCurrentRun() || finished) {\n        return;\n    }\n\n    const maxAttempts = 320;\n    intervalid = setInterval(() => {\n        attempts++;\n        if (attempts > maxAttempts) {\n            cleanup();\n            return;\n        }\n\n        void refreshAndInject();\n    }, 250);\n\n    const container = document.querySelector('#fitem_id_advancedgrading') ||\n        document.querySelector('[data-region=\"grading-actions-form\"]') ||\n        document.body;\n\n    observer = new MutationObserver(() => {\n        if (!isCurrentRun() || finished) {\n            return;\n        }\n        tryInjection();\n    });\n\n    observer.observe(container, { childList: true, subtree: true });\n\n    setTimeout(() => {\n        if (isCurrentRun()) {\n            cleanup();\n        }\n    }, 90000);\n};\n"],"names":["activerunid","activecleanup","async","userid","assignmentid","courseid","runid","intervalid","observer","finished","successNotified","stableSuccessCount","attempts","isCurrentRun","cleanup","clearInterval","disconnect","strRubricArray","strRubricSuccess","Promise","all","cachedData","fetchcounter","tryInjection","parsed","data","message","reply","rubricResponse","rubric_response","rubric","guideResponse","assessment_guide_response","grade","status","mode","payload","JSON","parse","Array","isArray","parseInjectionData","e","rootInfo","selectors","selector","nodes","from","document","querySelectorAll","visible","find","node","offsetParent","getClientRects","length","root","candidates","resolveGradingRoot","gradingRoot","hasRubricRows","applied","detailed","injected","rubricData","ok","mismatches","reason","rows","forEach","criterionData","name","criterion","expected","parseFloat","levels","_criterionData$levels2","_criterionData$levels3","points","row","rowItem","cell","querySelector","textContent","trim","push","selected","levelCell","radio","checked","classList","contains","getAttribute","score","Math","abs","verifyRubricApplied","addNotification","type","setTimeout","refreshAndInject","Ajax","call","methodname","args","cmid","fetchDetails","exception","setInterval","container","body","MutationObserver","observe","childList","subtree"],"mappings":"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"}