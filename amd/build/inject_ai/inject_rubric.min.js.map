{"version":3,"file":"inject_rubric.min.js","sources":["../../src/inject_ai/inject_rubric.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Injects rubric selections and comments.\n *\n * @module      local_assign_ai/inject_ai/inject_rubric\n * @copyright   2025 Datacurso\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Notification from 'core/notification';\nimport { normalizeString } from './normalize_string';\n\n/**\n * Injects rubric selections and comments.\n *\n * @param {Array} rubricData The rubric data array.\n * @param {string} strRubricError Error string for validation.\n * @param {{detailed?: boolean, root?: Element|Document}} options Injection options.\n * @returns {boolean|Object} True or detailed injection result.\n */\nexport const injectRubric = (rubricData, strRubricError, options = {}) => {\n    const detailed = !!options.detailed;\n    const root = options.root || document;\n    if (!Array.isArray(rubricData)) {\n        Notification.addNotification({\n            message: strRubricError,\n            type: 'error'\n        });\n        if (detailed) {\n            return {\n                injected: false,\n                totalCriteria: 0,\n                matchedCriteria: 0,\n                fullyAppliedCriteria: 0,\n                availableCriteria: [],\n                details: [],\n            };\n        }\n        return false;\n    }\n\n    let anyInjected = false;\n    const allrows = Array.from(root.querySelectorAll('tr.criterion'));\n    const visiblerows = allrows.filter(row => row.offsetParent !== null || row.getClientRects().length > 0);\n    const criterionRows = visiblerows.length ? visiblerows : allrows;\n    const availableCriteria = criterionRows\n        .map((row) => {\n            const descriptionCell = row.querySelector('td.description');\n            return descriptionCell ? descriptionCell.textContent.trim() : '';\n        })\n        .filter((value) => !!value)\n        .slice(0, 20);\n    const details = [];\n    let matchedCriteria = 0;\n    let fullyAppliedCriteria = 0;\n\n    if (criterionRows.length === 0) {\n        if (detailed) {\n            return {\n                injected: false,\n                totalCriteria: rubricData.length,\n                matchedCriteria: 0,\n                fullyAppliedCriteria: 0,\n                availableCriteria,\n                details: rubricData.map((criterionData) => ({\n                    criterion: criterionData?.criterion || '',\n                    rowFound: false,\n                    levelFound: false,\n                    levelApplied: false,\n                    commentApplied: false,\n                    expectedPoints: criterionData?.levels?.[0]?.points ?? null,\n                })),\n            };\n        }\n        return false;\n    }\n\n    rubricData.forEach((criterionData) => {\n        const criterionName = criterionData.criterion;\n        const targetPoints = criterionData.levels[0].points;\n        const comment = criterionData.levels[0].comment;\n        const criterionResult = {\n            criterion: criterionName,\n            rowFound: false,\n            levelFound: false,\n            levelApplied: false,\n            commentApplied: false,\n            expectedPoints: targetPoints,\n            selectedPointsBefore: null,\n            selectedPointsAfter: null,\n            radioFound: false,\n            radioDisabled: false,\n            mutationAttempted: false,\n            checkedAfterManualSet: false,\n            checkedAfterEvents: false,\n            checkedAfterFallbackClick: false,\n            classAfterMutation: false,\n        };\n\n        const row = criterionRows.find((rowItem) => {\n            const descriptionCell = rowItem.querySelector('td.description');\n            if (!descriptionCell) {\n                return false;\n            }\n            const rowCriterionName = descriptionCell.textContent.trim();\n            return normalizeString(rowCriterionName) === normalizeString(criterionName);\n        });\n\n        if (!row) {\n            details.push(criterionResult);\n            return;\n        }\n\n        criterionResult.rowFound = true;\n        matchedCriteria++;\n\n        const levelCells = row.querySelectorAll('td.level');\n\n        levelCells.forEach((levelCell) => {\n            const radioInput = levelCell.querySelector('input[type=\"radio\"]');\n            const isSelected = !!radioInput?.checked || levelCell.classList.contains('checked');\n            if (!radioInput || !isSelected) {\n                return;\n            }\n            const scoreSpan = levelCell.querySelector('.scorevalue');\n            if (!scoreSpan) {\n                return;\n            }\n            criterionResult.selectedPointsBefore = parseFloat(scoreSpan.textContent.trim());\n        });\n\n        levelCells.forEach((levelCell) => {\n            const scoreSpan = levelCell.querySelector('.scorevalue');\n            if (!scoreSpan) {\n                return;\n            }\n\n            const points = parseFloat(scoreSpan.textContent.trim());\n            if (Math.abs(points - targetPoints) >= 0.1) {\n                return;\n            }\n\n            const radioInput = levelCell.querySelector('input[type=\"radio\"]');\n            if (!radioInput) {\n                return;\n            }\n\n            criterionResult.levelFound = true;\n            criterionResult.radioFound = true;\n            criterionResult.radioDisabled = !!radioInput.disabled;\n\n            const rowRadios = Array.from(row.querySelectorAll('input[type=\"radio\"]'));\n\n            if (!radioInput.checked && !radioInput.disabled) {\n                criterionResult.mutationAttempted = true;\n                const rowLevels = Array.from(row.querySelectorAll('td.level'));\n\n                rowRadios.forEach((radio) => {\n                    const shouldCheck = radio === radioInput;\n                    radio.checked = shouldCheck;\n                    radio.defaultChecked = shouldCheck;\n                    if (shouldCheck) {\n                        radio.setAttribute('checked', 'checked');\n                    } else {\n                        radio.removeAttribute('checked');\n                    }\n                });\n\n                criterionResult.checkedAfterManualSet = !!radioInput.checked;\n\n                rowLevels.forEach((cell) => {\n                    const isTarget = cell === levelCell;\n                    cell.classList.toggle('checked', isTarget);\n                    cell.setAttribute('aria-checked', isTarget ? 'true' : 'false');\n                });\n\n                criterionResult.classAfterMutation = levelCell.classList.contains('checked');\n\n                radioInput.dispatchEvent(new Event('input', { bubbles: true }));\n                radioInput.dispatchEvent(new Event('change', { bubbles: true }));\n                criterionResult.checkedAfterEvents = !!radioInput.checked;\n\n                if (!radioInput.checked && radioInput.click) {\n                    radioInput.click();\n                }\n\n                if (!radioInput.checked && levelCell.dispatchEvent) {\n                    levelCell.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));\n                }\n\n                criterionResult.checkedAfterFallbackClick = !!radioInput.checked;\n            }\n\n            if (radioInput.checked || levelCell.classList.contains('checked')) {\n                criterionResult.levelApplied = true;\n            }\n\n            if (radioInput.checked) {\n                criterionResult.selectedPointsAfter = points;\n            }\n        });\n\n        const remarkTextarea = row.querySelector('td.remark textarea');\n        if (remarkTextarea && comment) {\n            if (remarkTextarea.value !== comment) {\n                remarkTextarea.value = comment;\n                remarkTextarea.dispatchEvent(new Event('input', { bubbles: true }));\n                remarkTextarea.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n            criterionResult.commentApplied = remarkTextarea.value === comment;\n        }\n\n        if (criterionResult.levelApplied) {\n            anyInjected = true;\n        }\n\n        if (criterionResult.levelApplied && (!comment || criterionResult.commentApplied)) {\n            fullyAppliedCriteria++;\n        }\n\n        details.push(criterionResult);\n    });\n\n    const injected = anyInjected && fullyAppliedCriteria === rubricData.length;\n    if (detailed) {\n        return {\n            injected,\n            totalCriteria: rubricData.length,\n            matchedCriteria,\n            fullyAppliedCriteria,\n            availableCriteria,\n            details,\n        };\n    }\n    return injected;\n};\n"],"names":["rubricData","strRubricError","options","detailed","root","document","Array","isArray","addNotification","message","type","injected","totalCriteria","matchedCriteria","fullyAppliedCriteria","availableCriteria","details","anyInjected","allrows","from","querySelectorAll","visiblerows","filter","row","offsetParent","getClientRects","length","criterionRows","map","descriptionCell","querySelector","textContent","trim","value","slice","criterionData","criterion","rowFound","levelFound","levelApplied","commentApplied","expectedPoints","levels","_criterionData$levels2","_criterionData$levels3","points","forEach","criterionName","targetPoints","comment","criterionResult","selectedPointsBefore","selectedPointsAfter","radioFound","radioDisabled","mutationAttempted","checkedAfterManualSet","checkedAfterEvents","checkedAfterFallbackClick","classAfterMutation","find","rowItem","rowCriterionName","push","levelCells","levelCell","radioInput","isSelected","checked","classList","contains","scoreSpan","parseFloat","Math","abs","disabled","rowRadios","rowLevels","radio","shouldCheck","defaultChecked","setAttribute","removeAttribute","cell","isTarget","toggle","dispatchEvent","Event","bubbles","click","MouseEvent","cancelable","remarkTextarea"],"mappings":"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"}